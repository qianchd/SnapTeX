<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'none';
        script-src {{cspSource}} 'unsafe-inline' blob: https://unpkg.com;
        worker-src {{cspSource}} blob:;
        style-src {{cspSource}} 'unsafe-inline';
        font-src {{cspSource}} data:;
        img-src {{cspSource}} https: data: blob:;
        connect-src {{cspSource}} blob: https:;
    ">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="{{katexCssUri}}">
    <link rel="stylesheet" href="{{styleUri}}">
    <title>SnapTeX Preview</title>
</head>
<body>
<div id="content-root"></div>

<script>
    const vscode = acquireVsCodeApi();
    window.pdfReqQueue = [];
    window.renderPdfToCanvas = function(path, canvasId) {
        console.log(`[SnapTeX] Queueing PDF request for ${canvasId}`);
        window.pdfReqQueue.push({ path, canvasId });
    };

    /**
     * PreviewController: Manages the Webview State and Scrolling Logic
     * Implements a State Machine to handle transitions between Idle, Rendering, and Auto-Scrolling.
     */
    class PreviewController {
        constructor() {
            // DOM Elements
            this.contentRoot = document.getElementById('content-root');

            // State Machine: 'IDLE' | 'RENDERING' | 'SCROLLING_AUTO'
            this.state = 'SCROLLING_AUTO'; // Start locked (initial load)

            // State Data
            this.scrollTimeout = null;
            this.pendingScroll = null;
            this.isFirstLoad = true;

            // Anti-Jitter Data
            this.lastTargetIndex = -1;
            this.lastTargetRatio = 0;
            this.lastScrollTime = 0;

            // Bind Methods
            this.bindEvents();

            // Initial Signal
            vscode.postMessage({ command: 'webviewLoaded' });
        }

        bindEvents() {
            window.addEventListener('message', event => this.onMessage(event));
            window.addEventListener('scroll', () => this.onScroll());
            document.addEventListener('dblclick', event => this.onDoubleClick(event));
        }

        // --- State Management ---

        setState(newState) {
            this.state = newState;
            // console.log(`[State] -> ${newState}`); // Debug if needed
        }

        lockScrolling(duration) {
            this.setState('SCROLLING_AUTO');
            if (this.scrollTimeout) clearTimeout(this.scrollTimeout);
            this.scrollTimeout = setTimeout(() => {
                if (this.state === 'SCROLLING_AUTO') {
                    this.setState('IDLE');
                }
            }, duration);
        }

        // --- Event Handlers ---

        onMessage(event) {
            const { command, payload } = event.data;
            switch (command) {
                case 'update':
                    this.handleUpdate(payload);
                    break;
                case 'scrollToBlock':
                    this.handleScrollCommand(event.data);
                    break;
            }
        }

        handleUpdate(payload) {
            if (payload.type === 'full') {
                this.setState('RENDERING');
                const scrollState = this.saveScrollState();
                document.body.classList.add('preload-mode');

                this.smartFullUpdate(payload.html);

                document.fonts.ready.then(() => {
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            this.onRenderComplete(scrollState);
                        });
                    });
                });
            } else if (payload.type === 'patch') {
                this.applyPatch(payload);
            }

            if (payload.numbering) {
                requestAnimationFrame(() => this.applyNumbering(payload.numbering));
            }

            setTimeout(() => this.renderPendingPdfs(), 50);
        }

        onRenderComplete(savedScrollState) {
            this.setState('IDLE');
            document.body.classList.remove('preload-mode');

            let scrollHandled = false;
            if (this.pendingScroll) {
                this.executeScroll(this.pendingScroll);
                this.pendingScroll = null;
                scrollHandled = true;
            } else if (!this.isFirstLoad) {
                this.restoreScrollState(savedScrollState);
                scrollHandled = true;
            }

            this.isFirstLoad = false;

            // If no scroll action was taken, ensure we unlock quickly (similar to original logic)
            if (!scrollHandled && this.state === 'SCROLLING_AUTO') {
                 this.lockScrolling(200);
            } else if (!scrollHandled) {
                // Ensure we are IDLE if nothing happened
                this.setState('IDLE');
            }
        }

        handleScrollCommand(data) {
            if (this.state === 'RENDERING' || this.isFirstLoad) { this.pendingScroll = data; }
            else { this.executeScroll(data); }
        }

        onScroll() {
            // Block if locked
            if (this.state !== 'IDLE') return;

            // Throttle
            const now = Date.now();
            if (now - this.lastScrollTime < 100) return;
            this.lastScrollTime = now;

            // Find Center Block
            const blocks = document.querySelectorAll('.latex-block');
            const viewCenter = window.innerHeight / 2;

            for (const block of blocks) {
                const rect = block.getBoundingClientRect();
                if (rect.top <= viewCenter && rect.bottom >= viewCenter) {
                    const index = parseInt(block.getAttribute('data-index'));
                    let ratio = 0;
                    if (rect.height > 0) {
                        const offset = viewCenter - rect.top;
                        ratio = Math.max(0, Math.min(1, offset / rect.height));
                    }

                    // Anti-Loop Check (Optional: You can enable the lastTarget check here if desired,
                    // but sticking to your 'stable' version which just sends it)
                    vscode.postMessage({ command: 'syncScroll', index: index, ratio: ratio });
                    break;
                }
            }
        }

        onDoubleClick(event) {
            const block = event.target.closest('.latex-block');
            if (block) {
                const index = block.getAttribute('data-index');
                if (index !== null) {
                    const rect = block.getBoundingClientRect();
                    const relativeY = event.clientY - rect.top;
                    const ratio = Math.max(0, Math.min(1, relativeY / rect.height));
                    let anchorText = "";

                    // Anchor Logic
                    const selection = window.getSelection();
                    if (selection && selection.toString().trim().length > 0) {
                        anchorText = selection.toString().trim();
                    } else if (document.caretRangeFromPoint) {
                        const range = document.caretRangeFromPoint(event.clientX, event.clientY);
                        if (range && range.startContainer.nodeType === Node.TEXT_NODE) {
                            const text = range.startContainer.textContent;
                            const offset = range.startOffset;
                            let start = offset, end = offset;
                            while (start > 0 && /\S/.test(text[start - 1])) start--;
                            while (end < text.length && /\S/.test(text[end])) end++;
                            if (end > start) { anchorText = text.substring(start, end); }
                        }
                    }

                    vscode.postMessage({
                        command: 'revealLine',
                        index: parseInt(index),
                        ratio: ratio,
                        anchor: anchorText,
                        viewRatio: event.clientY / window.innerHeight
                    });
                }
            }
        }

        // --- Logic Methods ---

        saveScrollState() {
            const blocks = document.querySelectorAll('.latex-block');
            for (const block of blocks) {
                const rect = block.getBoundingClientRect();
                if (rect.bottom > 0 && rect.top < window.innerHeight) {
                    return { index: block.getAttribute('data-index'), ratio: -rect.top / rect.height, offset: -rect.top };
                }
            }
            return null;
        }

        restoreScrollState(state) {
            if (!state || !state.index) return;
            const block = document.querySelector('.latex-block[data-index="' + state.index + '"]');
            if (block) {
                const newTop = block.getBoundingClientRect().top + window.scrollY;
                let targetY = state.ratio >= 0 ? newTop + (block.offsetHeight * state.ratio) : newTop;

                // Lock and Scroll
                this.lockScrolling(500); // Standard lock for restore
                window.scrollTo({ top: targetY, behavior: 'auto' });
            }
        }

        executeScroll(data) {
            const { index, ratio, anchor, auto, viewRatio = 0.5 } = data;

            this.lastTargetIndex = index;
            this.lastTargetRatio = ratio || 0;

            const target = document.querySelector('.latex-block[data-index="' + index + '"]');
            if (target) {
                const calcY = () => {
                    if (!target.isConnected) return window.scrollY;
                    const rect = target.getBoundingClientRect();
                    const absoluteTop = rect.top + window.scrollY;
                    let y = absoluteTop + (ratio || 0) * rect.height - (window.innerHeight * viewRatio);
                    if (anchor) {
                        const textTop = this.findTextOffsetInBlock(target, anchor);
                        if (textTop !== null) {
                            y = textTop + window.scrollY - (window.innerHeight * viewRatio);
                        }
                    }
                    return y;
                };

                const targetY = calcY();
                const currentY = window.scrollY;

                // [Anti-Jitter Threshold] (Maintained from your stable version)
                if (Math.abs(currentY - targetY) < 50 && auto) {
                    return;
                }

                const lockTime = auto ? 600 : 1000;
                this.lockScrolling(lockTime);

                window.scrollTo({ top: targetY, behavior: 'auto' });

                if (!auto) {
                    target.classList.add('jump-highlight');
                    setTimeout(() => target.classList.remove('jump-highlight'), 1000);
                    if (anchor) this.highlightTextInNode(target, anchor);
                }

                // [First Load Correction]
                if (this.isFirstLoad) {
                    setTimeout(() => {
                        if (!target.isConnected) return;
                        const newTargetY = calcY();
                        // 75px Check
                        if (Math.abs(window.scrollY - newTargetY) > 75 || !auto) {
                            this.lockScrolling(500);
                            window.scrollTo({ top: newTargetY, behavior: 'auto' });
                        }
                    }, 150);
                }
            }
        }

        // --- DOM Helpers ---

        smartFullUpdate(newHtml) {
            const parser = new DOMParser();
            const newDoc = parser.parseFromString(newHtml, 'text/html');
            const newElements = Array.from(newDoc.body.children);
            const oldElements = Array.from(this.contentRoot.children);
            const maxLen = Math.max(newElements.length, oldElements.length);
            for (let i = 0; i < maxLen; i++) {
                const newEl = newElements[i];
                const oldEl = oldElements[i];
                if (!newEl) { if (oldEl) oldEl.remove(); continue; }
                if (!oldEl) { this.contentRoot.appendChild(newEl); continue; }
                if (oldEl.outerHTML !== newEl.outerHTML) { oldEl.replaceWith(newEl); }
            }
        }

        applyPatch(payload) {
            const { start, deleteCount, htmls = [], shift = 0 } = payload;
            const targetIndex = start + deleteCount;
            const referenceNode = this.contentRoot.children[targetIndex] || null;

            for (let i = 0; i < deleteCount; i++) {
                if (this.contentRoot.children[start]) this.contentRoot.removeChild(this.contentRoot.children[start]);
            }
            if (htmls.length > 0) {
                const fragment = document.createDocumentFragment();
                const tempDiv = document.createElement('div');
                htmls.forEach(html => {
                    tempDiv.innerHTML = html;
                    const node = tempDiv.firstElementChild;
                    if (node) fragment.appendChild(node);
                });
                this.contentRoot.insertBefore(fragment, referenceNode);
            }
            if (shift !== 0) {
                let node = this.contentRoot.children[start + htmls.length];
                while (node) {
                    const oldIdx = parseInt(node.getAttribute('data-index'));
                    if (!isNaN(oldIdx)) { node.setAttribute('data-index', oldIdx + shift); }
                    node = node.nextElementSibling;
                }
            }
            if (payload.dirtyBlocks) {
                Object.keys(payload.dirtyBlocks).forEach(indexStr => {
                    const idx = parseInt(indexStr);
                    const targetBlock = document.querySelector('.latex-block[data-index="' + idx + '"]');
                    if (targetBlock) { targetBlock.outerHTML = payload.dirtyBlocks[idx]; }
                });
            }
        }

        applyNumbering(data) {
            if (!data) return;
            const { blocks, labels } = data;
            for (const [idxStr, counts] of Object.entries(blocks)) {
                const idx = parseInt(idxStr);
                const blockEl = document.querySelector('.latex-block[data-index="' + idx + '"]');
                if (!blockEl) continue;
                const fill = (type, values) => {
                    if (!values || !values.length) return;
                    const spans = blockEl.querySelectorAll('.sn-cnt[data-type="' + type + '"]');
                    spans.forEach((span, i) => { if (values[i]) span.textContent = values[i]; });
                };
                fill('eq', counts.eq); fill('fig', counts.fig); fill('tbl', counts.tbl);
                fill('alg', counts.alg); fill('sec', counts.sec); fill('thm', counts.thm);
            }
            if (labels) {
                const refs = document.querySelectorAll('.sn-ref');
                refs.forEach(ref => {
                    const key = ref.getAttribute('data-key');
                    if (key && labels[key]) { ref.textContent = labels[key]; } else { ref.textContent = "??"; }
                });
            }
        }

        renderPendingPdfs() {
            const pdfCanvases = document.querySelectorAll('canvas[data-req-path]');
            pdfCanvases.forEach(canvas => {
                const path = canvas.getAttribute('data-req-path');
                const id = canvas.id;
                // Check if already rendered or requested
                if (path && id && !canvas.getAttribute('data-rendered') && !canvas.getAttribute('data-requested')) {
                    window.renderPdfToCanvas(path, id);
                }
            });
        }

        highlightTextInNode(rootElement, text) {
            if (!text || text.length < 3) return false;
            const walker = document.createTreeWalker(rootElement, NodeFilter.SHOW_TEXT, {
                acceptNode: (node) => {
                    if (node.parentElement && node.parentElement.closest('.katex')) return NodeFilter.FILTER_REJECT;
                    return NodeFilter.FILTER_ACCEPT;
                }
            });
            let node;
            while (node = walker.nextNode()) {
                const val = node.nodeValue;
                const index = val.indexOf(text);
                if (index >= 0) {
                    const range = document.createRange();
                    range.setStart(node, index);
                    range.setEnd(node, index + text.length);
                    const span = document.createElement('span');
                    span.className = 'highlight-word';
                    range.surroundContents(span);
                    setTimeout(() => {
                        const parent = span.parentNode;
                        if (parent) {
                            parent.replaceChild(document.createTextNode(span.textContent), span);
                            parent.normalize();
                        }
                    }, 2000);
                    return true;
                }
            }
            return false;
        }

        findTextOffsetInBlock(rootElement, text) {
            if (!text || text.length < 3) return null;
            const walker = document.createTreeWalker(rootElement, NodeFilter.SHOW_TEXT, {
                acceptNode: (node) => {
                    if (node.parentElement && node.parentElement.closest('.katex')) return NodeFilter.FILTER_REJECT;
                    return NodeFilter.FILTER_ACCEPT;
                }
            });
            let node;
            while (node = walker.nextNode()) {
                const val = node.nodeValue;
                const index = val.indexOf(text);
                if (index >= 0) {
                    const range = document.createRange();
                    range.setStart(node, index);
                    range.setEnd(node, index + text.length);
                    const rect = range.getBoundingClientRect();
                    return rect.top;
                }
            }
            return null;
        }
    }

    // Initialize Controller
    const controller = new PreviewController();
</script>

<script type="module">
    import * as pdfjsLib from '{{pdfJsUri}}';
    pdfjsLib.GlobalWorkerOptions.workerSrc = '{{pdfWorkerUri}}';

    // Helper: Base64 to Uint8Array
    function base64ToUint8Array(base64) {
        const binary_string = window.atob(base64);
        const len = binary_string.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    }

    // Listener for PDF Data
    window.addEventListener('message', event => {
        const msg = event.data;
        if (msg.command === 'pdfData') {
            renderPdfFromData(msg.id, msg.data);
        }
    });

    // Main PDF Render Function (Data driven)
    async function renderPdfFromData(canvasId, base64Data) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;

        try {
            const pdfData = base64ToUint8Array(base64Data);
            const loadingTask = pdfjsLib.getDocument({ data: pdfData });
            const pdfDocument = await loadingTask.promise;

            const page = await pdfDocument.getPage(1);
            const scale = 2;
            const viewport = page.getViewport({ scale: scale });
            if (canvas.width !== viewport.width || canvas.height !== viewport.height) {
                canvas.height = viewport.height;
                canvas.width = viewport.width;
            }
            const context = canvas.getContext('2d');
            await page.render({ canvasContext: context, viewport: viewport }).promise;

            canvas.setAttribute('data-rendered', 'true');
        } catch (error) {
            console.error('PDF render error:', error);
            const ctx = canvas.getContext('2d');
            ctx.font = '12px sans-serif';
            ctx.fillText('Error loading PDF', 10, 50);
        }
    }

    // Exposed function to initiate request
    const realRequestPdf = (path, canvasId) => {
        const canvas = document.getElementById(canvasId);
        // Check if already requested to avoid loop
        if (!canvas || canvas.getAttribute('data-requested') === 'true') return;

        canvas.setAttribute('data-requested', 'true');

        // Post message to extension to fetch file content
        vscode.postMessage({
            command: 'requestPdf',
            id: canvasId,
            path: path
        });
    };

    if (window.pdfReqQueue && window.pdfReqQueue.length > 0) {
        console.log(`[SnapTeX] Processing ${window.pdfReqQueue.length} queued PDF requests.`);
        window.pdfReqQueue.forEach(req => realRequestPdf(req.path, req.canvasId));
    }

    window.renderPdfToCanvas = realRequestPdf;
</script>
</body>
</html>