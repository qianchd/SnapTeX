<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'none';
        script-src {{cspSource}} 'unsafe-inline' blob: https://unpkg.com;
        worker-src {{cspSource}} blob:;
        style-src {{cspSource}} 'unsafe-inline';
        font-src {{cspSource}} data:;
        img-src {{cspSource}} https: data: blob:;
        connect-src {{cspSource}} blob: https:;
    ">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="{{katexCssUri}}">
    <link rel="stylesheet" href="{{styleUri}}">
    <title>SnapTeX Preview</title>
</head>
<body>

<div id="content-root"></div>

<script>
    const vscode = acquireVsCodeApi();

    // --- Global PDF Helper ---
    window.pdfReqQueue = [];
    window.renderPdfToCanvas = function(path, canvasId) {
        console.log(`[SnapTeX] Queueing PDF request for ${canvasId}`);
        window.pdfReqQueue.push({ path, canvasId });
    };

    /**
     * Manager: Handles multiple tooltip instances.
     */
    class TooltipManager {
        constructor() {
            this.activeTransientTooltip = null; // The current unpinned tooltip (reused)
            this.zIndexCounter = 1000;
            this.bindGlobalEvents();
        }

        bindGlobalEvents() {
            // Link Hover
            document.body.addEventListener('mouseover', (e) => {
                const link = e.target.closest('a');
                if (link && link.getAttribute('href')?.startsWith('#')) {
                    // Prevent triggering new preview inside an UNPINNED tooltip.
                    // This prevents infinite nesting or accidental popups while reading a transient tooltip.
                    const parentTooltip = link.closest('.hover-tooltip');
                    if (parentTooltip && !parentTooltip.classList.contains('pinned')) {
                        return;
                    }
                    this.onLinkEnter(link);
                }
            });

            document.body.addEventListener('mouseout', (e) => {
                const link = e.target.closest('a');
                if (link && link.getAttribute('href')?.startsWith('#')) {
                    // [FIX] Don't trigger leave if moving internally within the tooltip or into the tooltip
                    // This prevents the hide timer from starting when hovering links inside the tooltip itself
                    if (this.activeTransientTooltip &&
                        this.activeTransientTooltip.element.contains(e.relatedTarget)) {
                        return;
                    }
                    this.onLinkLeave();
                }
            });

            // Global Mouse Interaction (Delegated to instances usually, but handled here for coordination)
            window.addEventListener('mousemove', (e) => this.broadcastMouseMove(e));
            window.addEventListener('mouseup', () => this.broadcastMouseUp());
        }

        onLinkEnter(link) {
            // 1. If we have an active transient tooltip, use it.
            // 2. If it's pinned, it's no longer transient, so we create a NEW one.
            if (!this.activeTransientTooltip || this.activeTransientTooltip.isPinned) {
                this.activeTransientTooltip = new Tooltip(this);
            }

            this.activeTransientTooltip.scheduleShow(link);
        }

        onLinkLeave() {
            if (this.activeTransientTooltip) {
                this.activeTransientTooltip.onLinkLeave();
            }
        }

        getTopZIndex() {
            return ++this.zIndexCounter;
        }

        // Notify all tooltips of mouse moves (for drag/resize)
        broadcastMouseMove(e) {
            // Optimization: Only strictly needed if we tracked active draggers globally,
            // but currently Tooltip instances listen to window events conditionally.
            // We can leave this empty or use it to manage cursors.
        }

        broadcastMouseUp() {
            // Handled by instances
        }
    }

    /**
     * Individual Tooltip Window Class
     */
    class Tooltip {
        constructor(manager) {
            this.manager = manager;
            this.element = this.createDOM();
            document.body.appendChild(this.element);

            // References
            this.header = this.element.querySelector('.tooltip-header');
            this.contentContainer = this.element.querySelector('.tooltip-content');
            this.pinBtn = this.element.querySelector('.pin-btn');
            this.closeBtn = this.element.querySelector('.close-btn');

            // Handles
            this.resizeRight = this.element.querySelector('.resize-handle-right');
            this.resizeBottom = this.element.querySelector('.resize-handle-bottom');
            this.resizeCorner = this.element.querySelector('.resize-handle-corner');

            // State
            this.isPinned = false;
            this.currentLink = null;
            this.hideTimer = null;
            this.showTimer = null;

            this.isDragging = false;
            this.resizeState = null;

            this.bindEvents();
            this.bringToFront();
        }

        createDOM() {
            const el = document.createElement('div');
            el.className = 'hover-tooltip';
            el.innerHTML = `
                <div class="tooltip-header">
                    <span class="drag-handle-icon">::::</span>
                    <div class="header-controls">
                        <button class="icon-btn pin-btn" title="Pin / Unpin">ðŸ“Œ</button>
                        <button class="icon-btn close-btn" title="Close">âœ•</button>
                    </div>
                </div>
                <div class="tooltip-content"></div>
                <div class="resize-handle-right"></div>
                <div class="resize-handle-bottom"></div>
                <div class="resize-handle-corner"></div>
            `;
            return el;
        }

        bindEvents() {
            // Self Hover (Prevent hide)
            this.element.addEventListener('mouseenter', () => this.clearHideTimer());
            this.element.addEventListener('mouseleave', () => this.startHideTimer());

            // Bring to front on click
            this.element.addEventListener('mousedown', () => this.bringToFront());

            // Controls
            this.pinBtn.addEventListener('click', (e) => { e.stopPropagation(); this.togglePin(); });
            this.closeBtn.addEventListener('click', (e) => { e.stopPropagation(); this.dispose(); });

            // Drag
            this.header.addEventListener('mousedown', (e) => this.startDrag(e));

            // Resize
            this.resizeBottom.addEventListener('mousedown', (e) => this.startResize(e, false, true));
            this.resizeRight.addEventListener('mousedown', (e) => this.startResize(e, true, false));
            this.resizeCorner.addEventListener('mousedown', (e) => this.startResize(e, true, true));

            // Window level events for Drag/Resize continuity
            // We use bounded functions to be able to remove them later (memory management)
            this._onWindowMouseMove = (e) => this.onMouseMove(e);
            this._onWindowMouseUp = (e) => this.onMouseUp(e);
            window.addEventListener('mousemove', this._onWindowMouseMove);
            window.addEventListener('mouseup', this._onWindowMouseUp);
        }

        bringToFront() {
            this.element.style.zIndex = this.manager.getTopZIndex();
        }

        togglePin() {
            this.isPinned = !this.isPinned;
            if (this.isPinned) {
                this.pinBtn.classList.add('active');
                // Mark as pinned for CSS or logic checks
                this.element.classList.add('pinned');
                this.clearHideTimer(); // Stay open indefinitely
                // Once pinned, the manager forgets this tooltip as the "transient" one,
                // so the next hover will create a NEW tooltip.
                if (this.manager.activeTransientTooltip === this) {
                    this.manager.activeTransientTooltip = null;
                }
            } else {
                this.pinBtn.classList.remove('active');
                this.element.classList.remove('pinned');
                // Revert to auto-hide behavior
                // Note: We don't necessarily re-attach to manager.activeTransientTooltip.
                // We just let it close naturally on mouse leave.
                // If mouse is already outside, close immediately (or start timer).
                if (!this.element.matches(':hover')) {
                    this.startHideTimer();
                }
            }
        }

        dispose() {
            if (this.element && this.element.parentNode) {
                this.element.parentNode.removeChild(this.element);
            }
            window.removeEventListener('mousemove', this._onWindowMouseMove);
            window.removeEventListener('mouseup', this._onWindowMouseUp);

            // Clean up manager reference if we were the active transient one
            if (this.manager.activeTransientTooltip === this) {
                this.manager.activeTransientTooltip = null;
            }
        }

        // --- Drag Logic ---
        startDrag(e) {
            this.isDragging = true;

            // [FIX] First, lock the geometry to absolute pixels
            this.ensureAbsolutePosition();

            // [FIX] Then measure (now that layout is stable)
            const rect = this.element.getBoundingClientRect();

            this.element.style.cursor = 'grabbing';
            this.dragOffset = { x: e.clientX - rect.left, y: e.clientY - rect.top };

            e.preventDefault();
        }

        startResize(e, dirX, dirY) {
            // [FIX] First, lock the geometry.
            // This converts 'auto' width/height to explicit 'px' values immediately.
            this.ensureAbsolutePosition();

            // [FIX] Then capture the starting dimensions from the locked element
            const rect = this.element.getBoundingClientRect();

            this.resizeState = {
                startX: e.clientX,
                startY: e.clientY,
                startWidth: rect.width, // Using rect.width is safer with border-box
                startHeight: rect.height,
                dirX, dirY
            };

            // Release constraints to allow resizing
            this.element.style.maxHeight = 'none';
            this.element.style.maxWidth = 'none';

            e.preventDefault();
            e.stopPropagation();
        }

        ensureAbsolutePosition() {
            const rect = this.element.getBoundingClientRect();

            // Disable CSS centering
            this.element.style.transform = 'none';

            // Freeze position
            this.element.style.left = `${rect.left}px`;
            this.element.style.top = `${rect.top}px`;
            this.element.style.bottom = '';

            // Freeze dimensions (Essential for smooth resizing start)
            this.element.style.width = `${rect.width}px`;
            this.element.style.height = `${rect.height}px`;
        }

        onMouseMove(e) {
            if (this.isDragging) {
                const x = e.clientX - this.dragOffset.x;
                const y = e.clientY - this.dragOffset.y;
                this.element.style.left = `${x}px`;
                this.element.style.top = `${y}px`;
                // Ensure transform is cleared so left/top work absolutely
                this.element.style.transform = 'none';
            } else if (this.resizeState) {
                const { startX, startY, startWidth, startHeight, dirX, dirY } = this.resizeState;
                if (dirX) {
                    this.element.style.width = `${Math.max(300, startWidth + (e.clientX - startX))}px`;
                }
                if (dirY) {
                    this.element.style.height = `${Math.max(100, startHeight + (e.clientY - startY))}px`;
                }
            }
        }

        onMouseUp() {
            this.isDragging = false;
            this.resizeState = null;
            this.element.style.cursor = '';
        }

        // --- Show/Hide Logic ---
        scheduleShow(link) {
            this.clearHideTimer();
            if (this.currentLink === link && this.element.classList.contains('visible')) return;

            // Cancel any pending show for OTHER links on this same tooltip
            if (this.showTimer) clearTimeout(this.showTimer);

            this.showTimer = setTimeout(() => {
                this.onLinkEnter(link);
            }, 200);
        }

        cancelShow() {
            if (this.showTimer) {
                clearTimeout(this.showTimer);
                this.showTimer = null;
            }
        }

        onLinkEnter(link) {
            this.currentLink = link;
            const targetId = link.getAttribute('href').substring(1); // Remove '#'
            this.showPreview(link, targetId);
        }

        onLinkLeave() {
            this.cancelShow();
            this.startHideTimer();
        }

        startHideTimer() {
            if (this.isPinned) return; // Never hide if pinned

            if (this.hideTimer) clearTimeout(this.hideTimer);
            this.hideTimer = setTimeout(() => {
                this.hide();
            }, 300);
        }

        clearHideTimer() {
            if (this.hideTimer) {
                clearTimeout(this.hideTimer);
                this.hideTimer = null;
            }
        }

        hide() {
            this.element.classList.remove('visible');
            // Wait for transition to finish then remove from DOM (since it's transient)
            setTimeout(() => {
                if (!this.element.classList.contains('visible')) {
                    this.dispose();
                }
            }, 200);
        }

        showPreview(linkElement, targetId) {
            const targetEl = document.getElementById(targetId);
            if (!targetEl) return;

            const container = targetEl.closest('.latex-block') || targetEl.closest('.bib-item');
            if (!container) return;

            this.contentContainer.innerHTML = '';
            const frag = document.createDocumentFragment();

            if (container.classList.contains('latex-block')) {
                const prev = container.previousElementSibling;
                if (prev && prev.classList.contains('latex-block')) {
                    const clone = prev.cloneNode(true);
                    clone.classList.add('context-block');
                    this.cleanNode(clone);
                    frag.appendChild(clone);
                }
                const current = container.cloneNode(true);
                current.classList.add('target-block');
                this.cleanNode(current);
                frag.appendChild(current);
                const next = container.nextElementSibling;
                if (next && next.classList.contains('latex-block')) {
                    const clone = next.cloneNode(true);
                    clone.classList.add('context-block');
                    this.cleanNode(clone);
                    frag.appendChild(clone);
                }
            } else {
                const clone = container.cloneNode(true);
                this.cleanNode(clone);
                frag.appendChild(clone);
            }

            this.contentContainer.appendChild(frag);
            this.refreshPDFs();
            this.positionTooltip(linkElement);

            // Make visible (ensure DOM is updated first)
            requestAnimationFrame(() => {
                this.element.classList.add('visible');
            });
        }

        cleanNode(node) {
            if (node.id) node.removeAttribute('id');
            node.querySelectorAll('[id]').forEach(el => el.removeAttribute('id'));
        }

        refreshPDFs() {
            const canvases = this.contentContainer.querySelectorAll('canvas[data-req-path]');
            canvases.forEach(canvas => {
                const newId = 'tooltip-pdf-' + Math.random().toString(36).substr(2, 9);
                canvas.id = newId;
                canvas.removeAttribute('data-rendered');
                canvas.removeAttribute('data-requested');
                const path = canvas.getAttribute('data-req-path');
                if (path) { window.renderPdfToCanvas(path, newId); }
            });
        }

        positionTooltip(linkElement) {
            const linkRect = linkElement.getBoundingClientRect();
            const viewportHeight = window.innerHeight;
            const margin = 15;

            // Vertical Flip
            const isTopHalf = linkRect.top < (viewportHeight / 2);

            if (isTopHalf) {
                // Show Below
                this.element.style.top = `${linkRect.bottom + margin}px`;
            } else {
                // Show Above (Using Bottom property to stick to link)
                const bottomDist = viewportHeight - linkRect.top + margin;
                this.element.style.bottom = `${bottomDist}px`;
                this.element.style.top = 'auto'; // Clear top
            }
        }
    }

    // --- Main Preview Controller ---
    class PreviewController {
        constructor() {
            this.contentRoot = document.getElementById('content-root');
            this.state = 'SCROLLING_AUTO';
            this.scrollTimeout = null;
            this.pendingScroll = null;
            this.isFirstLoad = true;
            this.lastTargetIndex = -1;
            this.lastTargetRatio = 0;
            this.lastScrollTime = 0;

            // Initialize Tooltip Manager
            this.tooltipManager = new TooltipManager();

            this.bindEvents();
            vscode.postMessage({ command: 'webviewLoaded' });
        }

        bindEvents() {
            window.addEventListener('message', event => this.onMessage(event));
            window.addEventListener('scroll', () => this.onScroll());
            document.addEventListener('dblclick', event => this.onDoubleClick(event));
        }

        setState(newState) { this.state = newState; }

        lockScrolling(duration) {
            this.setState('SCROLLING_AUTO');
            if (this.scrollTimeout) clearTimeout(this.scrollTimeout);
            this.scrollTimeout = setTimeout(() => {
                if (this.state === 'SCROLLING_AUTO') { this.setState('IDLE'); }
            }, duration);
        }

        onMessage(event) {
            const { command, payload } = event.data;
            switch (command) {
                case 'update': this.handleUpdate(payload); break;
                case 'scrollToBlock': this.handleScrollCommand(event.data); break;
            }
        }

        handleUpdate(payload) {
            if (payload.type === 'full') {
                this.setState('RENDERING');
                const scrollState = this.saveScrollState();
                document.body.classList.add('preload-mode');
                this.smartFullUpdate(payload.html);
                document.fonts.ready.then(() => {
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => { this.onRenderComplete(scrollState); });
                    });
                });
            } else if (payload.type === 'patch') {
                this.applyPatch(payload);
            }
            if (payload.numbering) {
                requestAnimationFrame(() => this.applyNumbering(payload.numbering));
            }
            setTimeout(() => this.renderPendingPdfs(), 50);
        }

        onRenderComplete(savedScrollState) {
            this.setState('IDLE');
            document.body.classList.remove('preload-mode');
            let scrollHandled = false;
            if (this.pendingScroll) {
                this.executeScroll(this.pendingScroll);
                this.pendingScroll = null;
                scrollHandled = true;
            } else if (!this.isFirstLoad) {
                this.restoreScrollState(savedScrollState);
                scrollHandled = true;
            }
            this.isFirstLoad = false;
            if (!scrollHandled && this.state === 'SCROLLING_AUTO') { this.lockScrolling(200); }
            else if (!scrollHandled) { this.setState('IDLE'); }
        }

        handleScrollCommand(data) {
            if (this.state === 'RENDERING' || this.isFirstLoad) { this.pendingScroll = data; }
            else { this.executeScroll(data); }
        }

        onScroll() {
            if (this.state !== 'IDLE') return;
            const now = Date.now();
            if (now - this.lastScrollTime < 100) return;
            this.lastScrollTime = now;
            const blocks = document.querySelectorAll('.latex-block');
            const viewCenter = window.innerHeight / 2;
            for (const block of blocks) {
                const rect = block.getBoundingClientRect();
                if (rect.top <= viewCenter && rect.bottom >= viewCenter) {
                    const index = parseInt(block.getAttribute('data-index'));
                    let ratio = 0;
                    if (rect.height > 0) {
                        const offset = viewCenter - rect.top;
                        ratio = Math.max(0, Math.min(1, offset / rect.height));
                    }
                    vscode.postMessage({ command: 'syncScroll', index: index, ratio: ratio });
                    break;
                }
            }
        }

        onDoubleClick(event) {
            const block = event.target.closest('.latex-block');
            if (block) {
                const index = block.getAttribute('data-index');
                if (index !== null) {
                    const rect = block.getBoundingClientRect();
                    const relativeY = event.clientY - rect.top;
                    const ratio = Math.max(0, Math.min(1, relativeY / rect.height));
                    let anchorText = "";
                    const selection = window.getSelection();
                    if (selection && selection.toString().trim().length > 0) {
                        anchorText = selection.toString().trim();
                    } else if (document.caretRangeFromPoint) {
                        const range = document.caretRangeFromPoint(event.clientX, event.clientY);
                        if (range && range.startContainer.nodeType === Node.TEXT_NODE) {
                            const text = range.startContainer.textContent;
                            const offset = range.startOffset;
                            let start = offset, end = offset;
                            while (start > 0 && /\S/.test(text[start - 1])) start--;
                            while (end < text.length && /\S/.test(text[end])) end++;
                            if (end > start) { anchorText = text.substring(start, end); }
                        }
                    }
                    vscode.postMessage({
                        command: 'revealLine', index: parseInt(index), ratio: ratio, anchor: anchorText, viewRatio: event.clientY / window.innerHeight
                    });
                }
            }
        }

        saveScrollState() {
            const blocks = document.querySelectorAll('.latex-block');
            for (const block of blocks) {
                const rect = block.getBoundingClientRect();
                if (rect.bottom > 0 && rect.top < window.innerHeight) {
                    return { index: block.getAttribute('data-index'), ratio: -rect.top / rect.height, offset: -rect.top };
                }
            }
            return null;
        }

        restoreScrollState(state) {
            if (!state || !state.index) return;
            const block = document.querySelector('.latex-block[data-index="' + state.index + '"]');
            if (block) {
                const newTop = block.getBoundingClientRect().top + window.scrollY;
                let targetY = state.ratio >= 0 ? newTop + (block.offsetHeight * state.ratio) : newTop;
                this.lockScrolling(500);
                window.scrollTo({ top: targetY, behavior: 'auto' });
            }
        }

        executeScroll(data) {
            const { index, ratio, anchor, auto, viewRatio = 0.5 } = data;
            this.lastTargetIndex = index;
            this.lastTargetRatio = ratio || 0;
            const target = document.querySelector('.latex-block[data-index="' + index + '"]');
            if (target) {
                const calcY = () => {
                    if (!target.isConnected) return window.scrollY;
                    const rect = target.getBoundingClientRect();
                    const absoluteTop = rect.top + window.scrollY;
                    let y = absoluteTop + (ratio || 0) * rect.height - (window.innerHeight * viewRatio);
                    if (anchor) {
                        const textTop = this.findTextOffsetInBlock(target, anchor);
                        if (textTop !== null) { y = textTop + window.scrollY - (window.innerHeight * viewRatio); }
                    }
                    return y;
                };
                const targetY = calcY();
                const currentY = window.scrollY;
                if (Math.abs(currentY - targetY) < 50 && auto) { return; }
                const lockTime = auto ? 600 : 1000;
                this.lockScrolling(lockTime);
                window.scrollTo({ top: targetY, behavior: 'auto' });
                if (!auto) {
                    target.classList.add('jump-highlight');
                    setTimeout(() => target.classList.remove('jump-highlight'), 1000);
                    if (anchor) this.highlightTextInNode(target, anchor);
                }
                if (this.isFirstLoad) {
                    setTimeout(() => {
                        if (!target.isConnected) return;
                        const newTargetY = calcY();
                        if (Math.abs(window.scrollY - newTargetY) > 75 || !auto) {
                            this.lockScrolling(500);
                            window.scrollTo({ top: newTargetY, behavior: 'auto' });
                        }
                    }, 150);
                }
            }
        }

        smartFullUpdate(newHtml) {
            const parser = new DOMParser();
            const newDoc = parser.parseFromString(newHtml, 'text/html');
            const newElements = Array.from(newDoc.body.children);
            const oldElements = Array.from(this.contentRoot.children);
            const maxLen = Math.max(newElements.length, oldElements.length);
            for (let i = 0; i < maxLen; i++) {
                const newEl = newElements[i];
                const oldEl = oldElements[i];
                if (!newEl) { if (oldEl) oldEl.remove(); continue; }
                if (!oldEl) { this.contentRoot.appendChild(newEl); continue; }
                if (oldEl.outerHTML !== newEl.outerHTML) { oldEl.replaceWith(newEl); }
            }
        }

        applyPatch(payload) {
            const { start, deleteCount, htmls = [], shift = 0 } = payload;
            const targetIndex = start + deleteCount;
            const referenceNode = this.contentRoot.children[targetIndex] || null;
            for (let i = 0; i < deleteCount; i++) {
                if (this.contentRoot.children[start]) this.contentRoot.removeChild(this.contentRoot.children[start]);
            }
            if (htmls.length > 0) {
                const fragment = document.createDocumentFragment();
                const tempDiv = document.createElement('div');
                htmls.forEach(html => {
                    tempDiv.innerHTML = html;
                    const node = tempDiv.firstElementChild;
                    if (node) fragment.appendChild(node);
                });
                this.contentRoot.insertBefore(fragment, referenceNode);
            }
            if (shift !== 0) {
                let node = this.contentRoot.children[start + htmls.length];
                while (node) {
                    const oldIdx = parseInt(node.getAttribute('data-index'));
                    if (!isNaN(oldIdx)) { node.setAttribute('data-index', oldIdx + shift); }
                    node = node.nextElementSibling;
                }
            }
            if (payload.dirtyBlocks) {
                Object.keys(payload.dirtyBlocks).forEach(indexStr => {
                    const idx = parseInt(indexStr);
                    const targetBlock = document.querySelector('.latex-block[data-index="' + idx + '"]');
                    if (targetBlock) { targetBlock.outerHTML = payload.dirtyBlocks[idx]; }
                });
            }
        }

        applyNumbering(data) {
            if (!data) return;
            const { blocks, labels } = data;
            for (const [idxStr, counts] of Object.entries(blocks)) {
                const idx = parseInt(idxStr);
                const blockEl = document.querySelector('.latex-block[data-index="' + idx + '"]');
                if (!blockEl) continue;
                const fill = (type, values) => {
                    if (!values || !values.length) return;
                    const spans = blockEl.querySelectorAll('.sn-cnt[data-type="' + type + '"]');
                    spans.forEach((span, i) => { if (values[i]) span.textContent = values[i]; });
                };
                fill('eq', counts.eq); fill('fig', counts.fig); fill('tbl', counts.tbl);
                fill('alg', counts.alg); fill('sec', counts.sec); fill('thm', counts.thm);
            }
            if (labels) {
                const refs = document.querySelectorAll('.sn-ref');
                refs.forEach(ref => {
                    const key = ref.getAttribute('data-key');
                    if (key && labels[key]) { ref.textContent = labels[key]; } else { ref.textContent = "??"; }
                });
            }
        }

        renderPendingPdfs() {
            const pdfCanvases = document.querySelectorAll('canvas[data-req-path]');
            pdfCanvases.forEach(canvas => {
                const path = canvas.getAttribute('data-req-path');
                const id = canvas.id;
                if (path && id && !canvas.getAttribute('data-rendered') && !canvas.getAttribute('data-requested')) {
                    window.renderPdfToCanvas(path, id);
                }
            });
        }

        highlightTextInNode(rootElement, text) {
            if (!text || text.length < 3) return false;
            const walker = document.createTreeWalker(rootElement, NodeFilter.SHOW_TEXT, {
                acceptNode: (node) => {
                    if (node.parentElement && node.parentElement.closest('.katex')) return NodeFilter.FILTER_REJECT;
                    return NodeFilter.FILTER_ACCEPT;
                }
            });
            let node;
            while (node = walker.nextNode()) {
                const val = node.nodeValue;
                const index = val.indexOf(text);
                if (index >= 0) {
                    const range = document.createRange();
                    range.setStart(node, index);
                    range.setEnd(node, index + text.length);
                    const span = document.createElement('span');
                    span.className = 'highlight-word';
                    range.surroundContents(span);
                    setTimeout(() => {
                        const parent = span.parentNode;
                        if (parent) {
                            parent.replaceChild(document.createTextNode(span.textContent), span);
                            parent.normalize();
                        }
                    }, 2000);
                    return true;
                }
            }
            return false;
        }

        findTextOffsetInBlock(rootElement, text) {
            if (!text || text.length < 3) return null;
            const walker = document.createTreeWalker(rootElement, NodeFilter.SHOW_TEXT, {
                acceptNode: (node) => {
                    if (node.parentElement && node.parentElement.closest('.katex')) return NodeFilter.FILTER_REJECT;
                    return NodeFilter.FILTER_ACCEPT;
                }
            });
            let node;
            while (node = walker.nextNode()) {
                const val = node.nodeValue;
                const index = val.indexOf(text);
                if (index >= 0) {
                    const range = document.createRange();
                    range.setStart(node, index);
                    range.setEnd(node, index + text.length);
                    const rect = range.getBoundingClientRect();
                    return rect.top;
                }
            }
            return null;
        }
    }

    const controller = new PreviewController();
</script>

<script type="module">
    import * as pdfjsLib from '{{pdfJsUri}}';
    pdfjsLib.GlobalWorkerOptions.workerSrc = '{{pdfWorkerUri}}';

    function base64ToUint8Array(base64) {
        const binary_string = window.atob(base64);
        const len = binary_string.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    }

    window.addEventListener('message', event => {
        const msg = event.data;
        if (msg.command === 'pdfData') {
            renderPdfFromData(msg.id, msg.data);
        }
    });

    async function renderPdfFromData(canvasId, base64Data) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;

        try {
            const pdfData = base64ToUint8Array(base64Data);
            const loadingTask = pdfjsLib.getDocument({ data: pdfData });
            const pdfDocument = await loadingTask.promise;

            const page = await pdfDocument.getPage(1);
            const scale = 2;
            const viewport = page.getViewport({ scale: scale });
            if (canvas.width !== viewport.width || canvas.height !== viewport.height) {
                canvas.height = viewport.height;
                canvas.width = viewport.width;
            }
            const context = canvas.getContext('2d');
            await page.render({ canvasContext: context, viewport: viewport }).promise;

            canvas.setAttribute('data-rendered', 'true');
        } catch (error) {
            console.error('PDF render error:', error);
            const ctx = canvas.getContext('2d');
            ctx.font = '12px sans-serif';
            ctx.fillText('Error loading PDF', 10, 50);
        }
    }

    const realRequestPdf = (path, canvasId) => {
        const canvas = document.getElementById(canvasId);
        if (!canvas || canvas.getAttribute('data-requested') === 'true') return;

        canvas.setAttribute('data-requested', 'true');

        vscode.postMessage({
            command: 'requestPdf',
            id: canvasId,
            path: path
        });
    };

    if (window.pdfReqQueue && window.pdfReqQueue.length > 0) {
        console.log(`[SnapTeX] Processing ${window.pdfReqQueue.length} queued PDF requests.`);
        window.pdfReqQueue.forEach(req => realRequestPdf(req.path, req.canvasId));
    }

    window.renderPdfToCanvas = realRequestPdf;
</script>
</body>
</html>