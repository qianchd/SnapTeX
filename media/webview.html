<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'none';
        script-src {{cspSource}} 'unsafe-inline' blob: https://unpkg.com;
        worker-src {{cspSource}} blob:;
        style-src {{cspSource}} 'unsafe-inline';
        font-src {{cspSource}} data:;
        img-src {{cspSource}} https: data:;
        connect-src {{cspSource}} blob: https:;
    ">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="{{katexCssUri}}">
    <link rel="stylesheet" href="{{styleUri}}">
    <title>SnapTeX Preview</title>
</head>
<body>
<div id="content-root"></div>

<script>
    const vscode = acquireVsCodeApi();
    const contentRoot = document.getElementById('content-root');
    const root = document.documentElement;

    function saveScrollState() {
        const blocks = document.querySelectorAll('.latex-block');
        for (const block of blocks) {
            const rect = block.getBoundingClientRect();
            if (rect.bottom > 0 && rect.top < window.innerHeight) {
                const index = block.getAttribute('data-index');
                const offset = -rect.top;
                const ratio = offset / rect.height;
                return { index, ratio, offset };
            }
        }
        return null;
    }

    function restoreScrollState(state) {
        if (!state || !state.index) return;
        const block = document.querySelector('.latex-block[data-index="' + state.index + '"]');
        if (block) {
            const newTop = block.getBoundingClientRect().top + window.scrollY;
            let targetY = state.ratio >= 0 ? newTop + (block.offsetHeight * state.ratio) : newTop;
            window.scrollTo({ top: targetY, behavior: 'auto' });
        }
    }

    function highlightTextInNode(rootElement, text) {
        if (!text || text.length < 3) return false;
        const walker = document.createTreeWalker(rootElement, NodeFilter.SHOW_TEXT, {
            acceptNode: (node) => {
                if (node.parentElement && node.parentElement.closest('.katex')) return NodeFilter.FILTER_REJECT;
                return NodeFilter.FILTER_ACCEPT;
            }
        });
        let node;
        while (node = walker.nextNode()) {
            const val = node.nodeValue;
            const index = val.indexOf(text);
            if (index >= 0) {
                const range = document.createRange();
                range.setStart(node, index);
                range.setEnd(node, index + text.length);
                const span = document.createElement('span');
                span.className = 'highlight-word';
                range.surroundContents(span);
                span.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
                setTimeout(() => {
                    const parent = span.parentNode;
                    if (parent) {
                        parent.replaceChild(document.createTextNode(span.textContent), span);
                        parent.normalize();
                    }
                }, 3000);
                return true;
            }
        }
        return false;
    }

    function smartFullUpdate(newHtml) {
        const parser = new DOMParser();
        const newDoc = parser.parseFromString(newHtml, 'text/html');
        const newElements = Array.from(newDoc.body.children);
        const oldElements = Array.from(contentRoot.children);
        const maxLen = Math.max(newElements.length, oldElements.length);
        for (let i = 0; i < maxLen; i++) {
            const newEl = newElements[i];
            const oldEl = oldElements[i];
            if (!newEl) { if (oldEl) oldEl.remove(); continue; }
            if (!oldEl) { contentRoot.appendChild(newEl); continue; }
            if (oldEl.outerHTML !== newEl.outerHTML) { oldEl.replaceWith(newEl); }
        }
    }

    // [Fix] Apply Numbering Logic
    function applyNumbering(data) {
        if (!data) return;
        const { blocks, labels } = data;

        // 1. Update Block Counters
        for (const [idxStr, counts] of Object.entries(blocks)) {
            const idx = parseInt(idxStr);
            const blockEl = document.querySelector('.latex-block[data-index="' + idx + '"]');
            if (!blockEl) continue;

            const fill = (type, values) => {
                if (!values || !values.length) return;
                const spans = blockEl.querySelectorAll('.sn-cnt[data-type="' + type + '"]');
                spans.forEach((span, i) => {
                    if (values[i]) span.textContent = values[i];
                });
            };

            fill('eq', counts.eq);
            fill('fig', counts.fig);
            fill('tbl', counts.tbl);
            fill('alg', counts.alg);
            fill('sec', counts.sec);
            fill('thm', counts.thm);
        }

        // 2. Update Global References (Links)
        if (labels) {
            const refs = document.querySelectorAll('.sn-ref');
            refs.forEach(ref => {
                const key = ref.getAttribute('data-key');
                if (key && labels[key]) {
                    ref.textContent = labels[key];
                } else {
                    ref.textContent = "??";
                }
            });
        }
    }

    window.addEventListener('message', event => {
        const { command, payload, index, ratio, anchor } = event.data;

        if (command === 'update') {
            // 1. DOM Update
            if (payload.type === 'full') {
                const scrollState = saveScrollState();
                document.body.classList.add('preload-mode');
                smartFullUpdate(payload.html);
                document.fonts.ready.then(() => {
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            restoreScrollState(scrollState);
                            document.body.classList.remove('preload-mode');
                        });
                    });
                });
            } else if (payload.type === 'patch') {
                const { start, deleteCount, htmls = [], shift = 0 } = payload;
                const targetIndex = start + deleteCount;
                const referenceNode = contentRoot.children[targetIndex] || null;
                for (let i = 0; i < deleteCount; i++) {
                    if (contentRoot.children[start]) contentRoot.removeChild(contentRoot.children[start]);
                }
                if (htmls.length > 0) {
                    const fragment = document.createDocumentFragment();
                    const tempDiv = document.createElement('div');
                    htmls.forEach(html => {
                        tempDiv.innerHTML = html;
                        const node = tempDiv.firstElementChild;
                        if (node) fragment.appendChild(node);
                    });
                    contentRoot.insertBefore(fragment, referenceNode);
                }
                if (shift !== 0) {
                    let node = contentRoot.children[start + htmls.length];
                    while (node) {
                        const oldIdx = parseInt(node.getAttribute('data-index'));
                        if (!isNaN(oldIdx)) {
                            node.setAttribute('data-index', oldIdx + shift);
                        }
                        node = node.nextElementSibling;
                    }
                }

                // [NEW] Handle Dirty Blocks (Side-channel updates)
                // This updates blocks that were not part of the main edit range but changed
                // indirectly (e.g., Bibliography updates when a citation is added).
                if (payload.dirtyBlocks) {
                    Object.keys(payload.dirtyBlocks).forEach(indexStr => {
                        const idx = parseInt(indexStr);
                        const newHtml = payload.dirtyBlocks[idx];

                        // Find the existing block by its data-index
                        const targetBlock = document.querySelector('.latex-block[data-index="' + idx + '"]');
                        if (targetBlock) {
                            // Replace it directly
                            targetBlock.outerHTML = newHtml;
                        }
                    });
                }
            }

            // 2. [Critical] Apply Numbering AFTER DOM Update
            if (payload.numbering) {
                // Use requestAnimationFrame to ensure DOM is ready
                requestAnimationFrame(() => {
                    applyNumbering(payload.numbering);
                });
            }

            // 3. Trigger PDF update
            setTimeout(() => {
                const pdfCanvases = document.querySelectorAll('canvas[data-pdf-src]');
                pdfCanvases.forEach(canvas => {
                    const uri = canvas.getAttribute('data-pdf-src');
                    const id = canvas.id;
                    const renderedUri = canvas.getAttribute('data-rendered-uri');
                    if (uri && id && renderedUri !== uri) {
                        window.renderPdfToCanvas(uri, id);
                    }
                });
            }, 50);
        }
        else if (command === 'scrollToBlock') {
            const target = document.querySelector('.latex-block[data-index="' + index + '"]');
            if (target) {
                target.classList.add('jump-highlight');
                setTimeout(() => target.classList.remove('jump-highlight'), 2000);
                let preciseFound = false;
                if (anchor) preciseFound = highlightTextInNode(target, anchor);
                if (!preciseFound) {
                    const rect = target.getBoundingClientRect();
                    const absoluteTop = rect.top + window.scrollY;
                    const offset = (ratio || 0) * rect.height;
                    const targetY = absoluteTop + offset - (window.innerHeight / 2);
                    window.scrollTo({ top: targetY, behavior: 'smooth' });
                }
            }
        }
    });

    document.addEventListener('dblclick', event => {
        const block = event.target.closest('.latex-block');
        if (block) {
            const index = block.getAttribute('data-index');
            if (index !== null) {
                const rect = block.getBoundingClientRect();
                const relativeY = event.clientY - rect.top;
                const ratio = Math.max(0, Math.min(1, relativeY / rect.height));
                let anchorText = "";
                const selection = window.getSelection();
                if (selection && selection.toString().trim().length > 0) {
                    anchorText = selection.toString().trim();
                } else if (document.caretRangeFromPoint) {
                    const range = document.caretRangeFromPoint(event.clientX, event.clientY);
                    if (range && range.startContainer.nodeType === Node.TEXT_NODE) {
                        const text = range.startContainer.textContent;
                        const offset = range.startOffset;
                        let start = offset;
                        let end = offset;
                        while (start > 0 && /\S/.test(text[start - 1])) start--;
                        while (end < text.length && /\S/.test(text[end])) end++;
                        if (end > start) {
                            anchorText = text.substring(start, end);
                        }
                    }
                }
                vscode.postMessage({
                    command: 'revealLine',
                    index: parseInt(index),
                    ratio: ratio,
                    anchor: anchorText
                });
            }
        }
    });
    vscode.postMessage({ command: 'webviewLoaded' });
</script>
<script type="module">
    import * as pdfjsLib from '{{pdfJsUri}}';
    pdfjsLib.GlobalWorkerOptions.workerSrc = '{{pdfWorkerUri}}';

    window.renderPdfToCanvas = async (pdfUri, canvasId) => {
        try {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            if (canvas.getAttribute('data-rendering') === 'true') return;
            canvas.setAttribute('data-rendering', 'true');
            const loadingTask = pdfjsLib.getDocument(pdfUri);
            const pdf = await loadingTask.promise;
            const page = await pdf.getPage(1);
            const scale = 3;
            const viewport = page.getViewport({ scale: scale });
            if (canvas.width !== viewport.width || canvas.height !== viewport.height) {
                canvas.height = viewport.height;
                canvas.width = viewport.width;
            }
            const context = canvas.getContext('2d');
            await page.render({ canvasContext: context, viewport: viewport }).promise;
            canvas.removeAttribute('data-rendering');
            canvas.setAttribute('data-rendered-uri', pdfUri);
        } catch (error) {
            console.error('PDF render error:', error);
            const c = document.getElementById(canvasId);
            if(c) c.removeAttribute('data-rendering');
        }
    };
    window.addEventListener('message', event => {
        // Logic merged into main listener above
    });
    vscode.postMessage({ command: 'webviewLoaded' });
</script>
</body>
</html>