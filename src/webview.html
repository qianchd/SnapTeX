<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'none';
        script-src {{cspSource}} 'unsafe-inline' blob: https://unpkg.com;
        worker-src {{cspSource}} blob:;
        style-src {{cspSource}} 'unsafe-inline';
        font-src {{cspSource}} data:;
        img-src {{cspSource}} https: data:;
        connect-src {{cspSource}} blob: https:;
    ">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="{{katexCssUri}}">
    <link rel="stylesheet" href="{{styleUri}}">
    <title>SnapTeX Preview</title>
</head>
<body>
<div id="content-root"></div>

<script>
    const vscode = acquireVsCodeApi();
    const contentRoot = document.getElementById('content-root');
    const root = document.documentElement;

    // --- Global State ---
    let isAutoScrolling = true; // Lock to prevent sending scroll events back to editor
    let scrollTimeout;

    // Rendering State Queue
    let isRendering = false;      // Is a full update currently in progress?
    let pendingScroll = null;     // Stores a scroll command received during rendering
    let isFirstLoad = true;       // Track first load to skip scroll restoration if needed

    function saveScrollState() {
        const blocks = document.querySelectorAll('.latex-block');
        for (const block of blocks) {
            const rect = block.getBoundingClientRect();
            if (rect.bottom > 0 && rect.top < window.innerHeight) {
                const index = block.getAttribute('data-index');
                const offset = -rect.top;
                const ratio = offset / rect.height;
                return { index, ratio, offset };
            }
        }
        return null;
    }

    function restoreScrollState(state) {
        if (!state || !state.index) return;
        const block = document.querySelector('.latex-block[data-index="' + state.index + '"]');
        if (block) {
            const newTop = block.getBoundingClientRect().top + window.scrollY;
            let targetY = state.ratio >= 0 ? newTop + (block.offsetHeight * state.ratio) : newTop;

            isAutoScrolling = true;
            window.scrollTo({ top: targetY, behavior: 'auto' });
        }
    }

    // Extracted Scroll Logic with Re-adjustment
    function executeScroll(data) {
        const { index, ratio, anchor, auto, viewRatio = 0.5 } = data;

        lastTargetIndex = index;
        lastTargetRatio = ratio || 0;

        const target = document.querySelector('.latex-block[data-index="' + index + '"]');
        if (target) {
            const calcY = () => {
                if (!target.isConnected) return window.scrollY;
                const rect = target.getBoundingClientRect();
                const absoluteTop = rect.top + window.scrollY;

                let y = absoluteTop + (ratio || 0) * rect.height - (window.innerHeight * viewRatio);

                if (anchor) {
                    const textTop = findTextOffsetInBlock(target, anchor);
                    if (textTop !== null) {
                        y = textTop + window.scrollY - (window.innerHeight * viewRatio);
                    }
                }
                return y;
            };

            const targetY = calcY();
            const currentY = window.scrollY;

            if (Math.abs(currentY - targetY) < 50) {
                return;
            }

            isAutoScrolling = true;
            if (scrollTimeout) clearTimeout(scrollTimeout);
            const lockTime = auto ? 600 : 1000;
            scrollTimeout = setTimeout(() => { isAutoScrolling = false; }, lockTime);

            window.scrollTo({ top: targetY, behavior: 'smooth' });

            if (!auto) {
                target.classList.add('jump-highlight');
                setTimeout(() => target.classList.remove('jump-highlight'), 1000);
                if (anchor) highlightTextInNode(target, anchor);
            }

            if (isFirstLoad) {
                setTimeout(() => {
                    if (!target.isConnected) return;
                    const newTargetY = calcY();
                    if (Math.abs(window.scrollY - newTargetY) >75) {
                        if (scrollTimeout) clearTimeout(scrollTimeout);
                        isAutoScrolling = true;
                        scrollTimeout = setTimeout(() => { isAutoScrolling = false; }, 500);
                        window.scrollTo({ top: newTargetY, behavior: 'auto' });
                    }
                }, 150);
            }
        }
    }

    function highlightTextInNode(rootElement, text) {
        if (!text || text.length < 3) return false;
        const walker = document.createTreeWalker(rootElement, NodeFilter.SHOW_TEXT, {
            acceptNode: (node) => {
                if (node.parentElement && node.parentElement.closest('.katex')) return NodeFilter.FILTER_REJECT;
                return NodeFilter.FILTER_ACCEPT;
            }
        });
        let node;
        while (node = walker.nextNode()) {
            const val = node.nodeValue;
            const index = val.indexOf(text);
            if (index >= 0) {
                const range = document.createRange();
                range.setStart(node, index);
                range.setEnd(node, index + text.length);
                const span = document.createElement('span');
                span.className = 'highlight-word';
                range.surroundContents(span);
                setTimeout(() => {
                    const parent = span.parentNode;
                    if (parent) {
                        parent.replaceChild(document.createTextNode(span.textContent), span);
                        parent.normalize();
                    }
                }, 2000);
                return true;
            }
        }
        return false;
    }

    function findTextOffsetInBlock(rootElement, text) {
        if (!text || text.length < 3) return null;
        const walker = document.createTreeWalker(rootElement, NodeFilter.SHOW_TEXT, {
            acceptNode: (node) => {
                if (node.parentElement && node.parentElement.closest('.katex')) return NodeFilter.FILTER_REJECT;
                return NodeFilter.FILTER_ACCEPT;
            }
        });
        let node;
        while (node = walker.nextNode()) {
            const val = node.nodeValue;
            const index = val.indexOf(text);
            if (index >= 0) {
                const range = document.createRange();
                range.setStart(node, index);
                range.setEnd(node, index + text.length);
                const rect = range.getBoundingClientRect();
                return rect.top;
            }
        }
        return null;
    }

    function smartFullUpdate(newHtml) {
        const parser = new DOMParser();
        const newDoc = parser.parseFromString(newHtml, 'text/html');
        const newElements = Array.from(newDoc.body.children);
        const oldElements = Array.from(contentRoot.children);
        const maxLen = Math.max(newElements.length, oldElements.length);
        for (let i = 0; i < maxLen; i++) {
            const newEl = newElements[i];
            const oldEl = oldElements[i];
            if (!newEl) { if (oldEl) oldEl.remove(); continue; }
            if (!oldEl) { contentRoot.appendChild(newEl); continue; }
            if (oldEl.outerHTML !== newEl.outerHTML) { oldEl.replaceWith(newEl); }
        }
    }

    function applyNumbering(data) {
        if (!data) return;
        const { blocks, labels } = data;
        for (const [idxStr, counts] of Object.entries(blocks)) {
            const idx = parseInt(idxStr);
            const blockEl = document.querySelector('.latex-block[data-index="' + idx + '"]');
            if (!blockEl) continue;
            const fill = (type, values) => {
                if (!values || !values.length) return;
                const spans = blockEl.querySelectorAll('.sn-cnt[data-type="' + type + '"]');
                spans.forEach((span, i) => { if (values[i]) span.textContent = values[i]; });
            };
            fill('eq', counts.eq); fill('fig', counts.fig); fill('tbl', counts.tbl);
            fill('alg', counts.alg); fill('sec', counts.sec); fill('thm', counts.thm);
        }
        if (labels) {
            const refs = document.querySelectorAll('.sn-ref');
            refs.forEach(ref => {
                const key = ref.getAttribute('data-key');
                if (key && labels[key]) { ref.textContent = labels[key]; } else { ref.textContent = "??"; }
            });
        }
    }

    window.addEventListener('message', event => {
        const { command, payload, index, ratio, anchor, auto, viewRatio = 0.5 } = event.data;
        if (command === 'update') {
            if (payload.type === 'full') {
                isRendering = true;
                const scrollState = saveScrollState();
                document.body.classList.add('preload-mode');
                smartFullUpdate(payload.html);
                document.fonts.ready.then(() => {
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            isRendering = false;
                            document.body.classList.remove('preload-mode');
                            // Track if we handled a pending scroll
                            let scrollHandled = false;
                            if (pendingScroll) {
                                console.log("[SnapTeX] Executing queued scroll command");
                                executeScroll(pendingScroll);
                                pendingScroll = null;
                                scrollHandled = true; // Mark as handled
                            } else if (!isFirstLoad) {
                                restoreScrollState(scrollState);
                            }
                            isFirstLoad = false;
                            // Only reset the lock here if executeScroll DID NOT run.
                            // If executeScroll ran, it set its own long timer (1000ms), which we must not overwrite with this 200ms one.
                            if (!scrollHandled) {
                                if (scrollTimeout) clearTimeout(scrollTimeout);
                                scrollTimeout = setTimeout(() => { isAutoScrolling = false; }, 200);
                            }
                        });
                    });
                });
            } else if (payload.type === 'patch') {
                const { start, deleteCount, htmls = [], shift = 0 } = payload;
                const targetIndex = start + deleteCount;
                const referenceNode = contentRoot.children[targetIndex] || null;
                for (let i = 0; i < deleteCount; i++) {
                    if (contentRoot.children[start]) contentRoot.removeChild(contentRoot.children[start]);
                }
                if (htmls.length > 0) {
                    const fragment = document.createDocumentFragment();
                    const tempDiv = document.createElement('div');
                    htmls.forEach(html => {
                        tempDiv.innerHTML = html;
                        const node = tempDiv.firstElementChild;
                        if (node) fragment.appendChild(node);
                    });
                    contentRoot.insertBefore(fragment, referenceNode);
                }
                if (shift !== 0) {
                    let node = contentRoot.children[start + htmls.length];
                    while (node) {
                        const oldIdx = parseInt(node.getAttribute('data-index'));
                        if (!isNaN(oldIdx)) { node.setAttribute('data-index', oldIdx + shift); }
                        node = node.nextElementSibling;
                    }
                }
                if (payload.dirtyBlocks) {
                    Object.keys(payload.dirtyBlocks).forEach(indexStr => {
                        const idx = parseInt(indexStr);
                        const targetBlock = document.querySelector('.latex-block[data-index="' + idx + '"]');
                        if (targetBlock) { targetBlock.outerHTML = payload.dirtyBlocks[idx]; }
                    });
                }
            }
            if (payload.numbering) { requestAnimationFrame(() => { applyNumbering(payload.numbering); }); }
            setTimeout(() => {
                const pdfCanvases = document.querySelectorAll('canvas[data-pdf-src]');
                pdfCanvases.forEach(canvas => {
                    const uri = canvas.getAttribute('data-pdf-src');
                    const id = canvas.id;
                    const renderedUri = canvas.getAttribute('data-rendered-uri');
                    if (uri && id && renderedUri !== uri) { window.renderPdfToCanvas(uri, id); }
                });
            }, 50);
        }
        else if (command === 'scrollToBlock') {
            if (isRendering || isFirstLoad) {
                console.log("[SnapTeX] Queuing scroll command");
                pendingScroll = event.data;
            } else {
                executeScroll(event.data);
            }
        }
    });

    document.addEventListener('dblclick', event => {
        const block = event.target.closest('.latex-block');
        if (block) {
            const index = block.getAttribute('data-index');
            if (index !== null) {
                const rect = block.getBoundingClientRect();
                const relativeY = event.clientY - rect.top;
                const ratio = Math.max(0, Math.min(1, relativeY / rect.height));
                let anchorText = "";
                const selection = window.getSelection();
                if (selection && selection.toString().trim().length > 0) {
                    anchorText = selection.toString().trim();
                } else if (document.caretRangeFromPoint) {
                    const range = document.caretRangeFromPoint(event.clientX, event.clientY);
                    if (range && range.startContainer.nodeType === Node.TEXT_NODE) {
                        const text = range.startContainer.textContent;
                        const offset = range.startOffset;
                        let start = offset;
                        let end = offset;
                        while (start > 0 && /\S/.test(text[start - 1])) start--;
                        while (end < text.length && /\S/.test(text[end])) end++;
                        if (end > start) { anchorText = text.substring(start, end); }
                    }
                }
                vscode.postMessage({
                    command: 'revealLine',
                    index: parseInt(index),
                    ratio: ratio,
                    anchor: anchorText,
                    viewRatio: event.clientY / window.innerHeight
                });
            }
        }
    });
    let lastScrollTime = 0;
    window.addEventListener('scroll', () => {
        if (isAutoScrolling) return;
        const now = Date.now();
        if (now - lastScrollTime < 100) return;
        lastScrollTime = now;
        const blocks = document.querySelectorAll('.latex-block');
        const viewCenter = window.innerHeight / 2;
        for (const block of blocks) {
            const rect = block.getBoundingClientRect();
            if (rect.top <= viewCenter && rect.bottom >= viewCenter) {
                const index = parseInt(block.getAttribute('data-index'));
                let ratio = 0;
                if (rect.height > 0) {
                    const offset = viewCenter - rect.top;
                    ratio = offset / rect.height;
                    ratio = Math.max(0, Math.min(1, ratio));
                }
                vscode.postMessage({ command: 'syncScroll', index: index, ratio: ratio });
                break;
            }
        }
    });
    vscode.postMessage({ command: 'webviewLoaded' });
</script>
<script type="module">
    import * as pdfjsLib from '{{pdfJsUri}}';
    pdfjsLib.GlobalWorkerOptions.workerSrc = '{{pdfWorkerUri}}';
    window.renderPdfToCanvas = async (pdfUri, canvasId) => {
        try {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            if (canvas.getAttribute('data-rendering') === 'true') return;
            canvas.setAttribute('data-rendering', 'true');
            const loadingTask = pdfjsLib.getDocument(pdfUri);
            const pdf = await loadingTask.promise;
            const page = await pdf.getPage(1);
            const scale = 3;
            const viewport = page.getViewport({ scale: scale });
            if (canvas.width !== viewport.width || canvas.height !== viewport.height) {
                canvas.height = viewport.height;
                canvas.width = viewport.width;
            }
            const context = canvas.getContext('2d');
            await page.render({ canvasContext: context, viewport: viewport }).promise;
            canvas.removeAttribute('data-rendering');
            canvas.setAttribute('data-rendered-uri', pdfUri);
        } catch (error) {
            console.error('PDF render error:', error);
            const c = document.getElementById(canvasId);
            if(c) c.removeAttribute('data-rendering');
        }
    };
    window.addEventListener('message', event => {
    });
</script>
</body>
</html>